(** Provides implementations of various numerical techniques to solve ordinary
    differential equations. *)

(** Required functions for solution of an ordinary differential equation.

    [t] is the container type holding collections of [elt], the type of the
    integrand, as well as [x], the type of the x-coordinates. *)
module type Integrable = sig
  (** Data container type. *)
  type 'a t

  (** Integrand data type. *)
  type elt

  (** {i x}-coordinate data type. *)
  type x

  (** Add two [elt]s together. *)
  val add : elt -> elt -> elt

  (** Add two [x]s together. *)
  val addx : x -> x -> x

  (** Subtract an [x] from another. *)
  val subx : x -> x -> x

  (** Multiply an [elt] by an [x]. *)
  val mulx : x -> elt -> elt

  (** Multiply an [elt] by a [float]. *)
  val mulf : float -> elt -> elt

  (** Multiply an [x] by a [float]. *)
  val mulfx : float -> x -> x

  (** Find the length of a [t]. *)
  val length : 'a t -> int

  (** Convert a [t] to a sequence. *)
  val to_seq : 'a t -> 'a Seq.t

  (** Collect a sequence into a [t]. *)
  val of_seq : 'a Seq.t -> 'a t
end

(** Signature of the fourth-order Runge-Kutta implementation generated by the
    {!RK4} functor. *)
module type RK4_sig = sig
  (** Data container type. *)
  type 'a t

  (** Integrand data type. *)
  type elt

  (** {i x}-coordinate data type. *)
  type x

  (** Take a single RK4 step of a certain size, given the right-hand side of the
      governing equation. *)
  val rk4_step : (x -> elt -> elt) -> x -> x -> elt -> elt

  (** Solve an ordinary differential equation over a fixed coordinate grid via
      RK4, given an initial condition.

      The governing equation is modeled by a single function that should return
      the first derivative of the dependent variable (this is the entire
      right-hand side of the equation, opposite only a first-order derivative.
      *)
  val rk4 : (x -> elt -> elt) -> x t -> elt -> elt t
end

(** Functor to generate an implementation of a fourth-order Runge-Kutta ODE
    solver. *)
module RK4 (I: Integrable): RK4_sig
  with type 'a t = 'a I.t and type elt = I.elt and type x = I.x

(** Required functions for solution of an ordinary differential equation with
    adaptive step sizes based on error estimation.

    [t] is the container type holding collections of [elt], the type of the
    integrand, as well as [x], the type of the x-coordinates. *)
module type Integrable_adaptive = sig
  (** Data container type. *)
  type 'a t

  (** Integrand data type. *)
  type elt

  (** {i x}-coordinate data type. *)
  type x

  (** Maximum number of iterations to converge to an optimal step size. *)
  val stepsize_maxiters : int

  (** The real-valued norm of an [elt]. *)
  val norm : elt -> float

  (** Add two [elt]s together. *)
  val add : elt -> elt -> elt

  (** Add two [x]s together. *)
  val addx : x -> x -> x

  (** Subtract an [elt] from another. *)
  val sub : elt -> elt -> elt

  (** Subtract an [x] from another. *)
  val subx : x -> x -> x

  (** Multiply an [elt] by an [x]. *)
  val mulx : x -> elt -> elt

  (** Multiply an [elt] by a [float]. *)
  val mulf : float -> elt -> elt

  (** Multiply an [x] by a [float]. *)
  val mulfx : float -> x -> x

  (** Compare two [x] values, following the normal [compare] convention. *)
  val comparex : x -> x -> int

  (** Find the length of a [t]. *)
  val length : 'a t -> int

  (** Convert a [t] to a sequence. *)
  val to_seq : 'a t -> 'a Seq.t

  (** Collect a sequence into a [t]. *)
  val of_seq : 'a Seq.t -> 'a t
end

(** Signature of the adaptive fourth-order Runge-Kutta implementation generated
    by the {!RK4} functor. *)
module type RK4_adaptive_sig = sig
  (** Data container type. *)
  type 'a t

  (** Integrand data type. *)
  type elt

  (** {i x}-coordinate data type. *)
  type x

  (** Error type returned if the adaptive step size routine fails to converge.
    *)
  type err =
    | No_converge of string

  (** Result wrapper around {!err}. *)
  type 'a res = ('a, err) result

  (** Take a single adaptive RK4 step based on an initial, test step size. This
      function iteratively converges to a new step size by repeatedly comparing
      the estimated local truncation error for subdivided steps until the
      desired error bound is met.

      Returns [No_converge] if the error bound cannot be met within
      {!Integrable_adaptive.stepsize_maxiters} iterations. If successful, the
      returned tuple is of the form [(new_x, new_y, new_dx)]. *)
  val rka_step
    : (x -> elt -> elt)
    -> float
    -> x
    -> x
    -> elt
    -> (x * elt * x) res

  (** Solve an ordinary differential equation over a fixed coordinate grid via
      RK4 with adaptive step sizes, given an initial condition.

      The governing equation is modeled by a single function that should return
      the first derivative of the dependent variable (this is the entire
      right-hand side of the equation, opposite only a first-order derivative.
      *)
  val rka
    : (x -> elt -> elt)
    -> float
    -> x
    -> (x * x)
    -> elt
    -> ((x t) * (elt t)) res
end

(** Functor to generate an implementation of an adaptive fourth-order
    Runge-Kutta ODE solver. *)
module RK4_adaptive (I: Integrable_adaptive): RK4_adaptive_sig
  with type 'a t = 'a I.t and type elt = I.elt and type x = I.x
